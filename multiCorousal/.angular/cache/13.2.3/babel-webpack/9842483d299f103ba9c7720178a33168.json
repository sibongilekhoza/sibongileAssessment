{"ast":null,"code":"import { Directive, Component, ChangeDetectionStrategy, Renderer2, ElementRef, NgZone, ViewChild, ContentChild, HostBinding, Optional, Self, Input, HostListener, NgModule } from '@angular/core';\nimport { ContentObserver } from '@angular/cdk/observers';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NgControl, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common'; // eslint-disable-next-line @angular-eslint/directive-class-suffix\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/observers';\nimport * as ɵngcc2 from '@angular/forms';\nconst _c0 = [\"notchLeading\"];\nconst _c1 = [\"notchMiddle\"];\nconst _c2 = [\"*\"];\nlet MdbAbstractFormControl = /*#__PURE__*/(() => {\n  class MdbAbstractFormControl {}\n\n  MdbAbstractFormControl.ɵfac = function MdbAbstractFormControl_Factory(t) {\n    return new (t || MdbAbstractFormControl)();\n  };\n\n  MdbAbstractFormControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbAbstractFormControl\n  });\n  return MdbAbstractFormControl;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @angular-eslint/component-class-suffix\n\n\nlet MdbLabelDirective = /*#__PURE__*/(() => {\n  class MdbLabelDirective {\n    constructor() {}\n\n  }\n\n  MdbLabelDirective.ɵfac = function MdbLabelDirective_Factory(t) {\n    return new (t || MdbLabelDirective)();\n  };\n\n  MdbLabelDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbLabelDirective,\n    selectors: [[\"\", \"mdbLabel\", \"\"]],\n    exportAs: [\"mdbLabel\"]\n  });\n  return MdbLabelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbFormControlComponent = /*#__PURE__*/(() => {\n  class MdbFormControlComponent {\n    constructor(_renderer, _contentObserver, _elementRef, _ngZone) {\n      this._renderer = _renderer;\n      this._contentObserver = _contentObserver;\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this.outline = true;\n      this._destroy$ = new Subject();\n      this._notchLeadingLength = 9;\n      this._labelMarginLeft = 0;\n      this._labelGapPadding = 8;\n      this._labelScale = 0.8;\n      this._recalculateGapWhenVisible = false;\n    }\n\n    get input() {\n      return this._formControl.input;\n    }\n\n    ngAfterContentInit() {\n      if (this._label) {\n        this._updateBorderGap();\n      } else {\n        this._renderer.addClass(this.input, 'placeholder-active');\n      }\n\n      this._updateLabelActiveState();\n\n      if (this._label) {\n        this._contentObserver.observe(this._label.nativeElement).pipe(takeUntil(this._destroy$)).subscribe(() => {\n          this._updateBorderGap();\n        });\n      }\n\n      this._formControl.stateChanges.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this._updateLabelActiveState();\n\n        if (this._label) {\n          this._updateBorderGap();\n        }\n      });\n\n      this._ngZone.runOutsideAngular(() => {\n        this._ngZone.onStable.pipe(takeUntil(this._destroy$)).subscribe(() => {\n          if (this._label && this._recalculateGapWhenVisible) {\n            this._updateBorderGap();\n          }\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.unsubscribe();\n    }\n\n    _getLabelWidth() {\n      return this._label.nativeElement.clientWidth * this._labelScale + this._labelGapPadding;\n    }\n\n    _updateBorderGap() {\n      // Element is in DOM but is not visible, we need to recalculate the gap when element\n      // is displayed. This problem may occur in components such as tabs where content of\n      // inactive tabs has display:none styles\n      if (this._isHidden()) {\n        this._recalculateGapWhenVisible = true;\n        return;\n      }\n\n      const notchLeadingWidth = `${this._labelMarginLeft + this._notchLeadingLength}px`;\n      const notchMiddleWidth = `${this._getLabelWidth()}px`;\n      this._notchLeading.nativeElement.style.width = notchLeadingWidth;\n      this._notchMiddle.nativeElement.style.width = notchMiddleWidth;\n      this._label.nativeElement.style.marginLeft = `${this._labelMarginLeft}px`;\n      this._recalculateGapWhenVisible = false;\n    }\n\n    _updateLabelActiveState() {\n      if (this._isLabelActive()) {\n        this._renderer.addClass(this.input, 'active');\n      } else {\n        this._renderer.removeClass(this.input, 'active');\n      }\n    }\n\n    _isLabelActive() {\n      return this._formControl && this._formControl.labelActive;\n    }\n\n    _isHidden() {\n      const el = this._elementRef.nativeElement;\n      return !el.offsetHeight && !el.offsetWidth;\n    }\n\n  }\n\n  MdbFormControlComponent.ɵfac = function MdbFormControlComponent_Factory(t) {\n    return new (t || MdbFormControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ContentObserver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MdbFormControlComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbFormControlComponent,\n    selectors: [[\"mdb-form-control\"]],\n    contentQueries: function MdbFormControlComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbAbstractFormControl, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbLabelDirective, 7, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._formControl = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._label = _t.first);\n      }\n    },\n    viewQuery: function MdbFormControlComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchLeading = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchMiddle = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function MdbFormControlComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"form-outline\", ctx.outline);\n      }\n    },\n    ngContentSelectors: _c2,\n    decls: 7,\n    vars: 0,\n    consts: [[1, \"form-notch\"], [1, \"form-notch-leading\"], [\"notchLeading\", \"\"], [1, \"form-notch-middle\"], [\"notchMiddle\", \"\"], [1, \"form-notch-trailing\"]],\n    template: function MdbFormControlComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 0);\n        ɵngcc0.ɵɵelement(2, \"div\", 1, 2);\n        ɵngcc0.ɵɵelement(4, \"div\", 3, 4);\n        ɵngcc0.ɵɵelement(6, \"div\", 5);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdbFormControlComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @angular-eslint/component-class-suffix\n\n\nlet MdbInputDirective = /*#__PURE__*/(() => {\n  class MdbInputDirective {\n    constructor(_elementRef, _renderer, _ngControl) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._ngControl = _ngControl;\n      this.stateChanges = new Subject();\n      this._focused = false;\n      this._color = '';\n      this._disabled = false;\n      this._readonly = false;\n    }\n\n    ngAfterViewInit() {\n      this._color = getComputedStyle(this._elementRef.nativeElement).color;\n\n      if (this._elementRef.nativeElement.type === 'date') {\n        this._updateTextColorForDateType();\n      }\n    }\n\n    get disabled() {\n      if (this._ngControl && this._ngControl.disabled !== null) {\n        return this._ngControl.disabled;\n      }\n\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    get readonly() {\n      return this._readonly;\n    }\n\n    set readonly(value) {\n      if (value) {\n        this._renderer.setAttribute(this._elementRef.nativeElement, 'readonly', '');\n      } else {\n        this._renderer.removeAttribute(this._elementRef.nativeElement, 'readonly');\n      }\n\n      this._readonly = coerceBooleanProperty(value);\n    }\n\n    get value() {\n      return this._elementRef.nativeElement.value;\n    }\n\n    set value(value) {\n      if (value !== this.value) {\n        this._elementRef.nativeElement.value = value;\n        this._value = value;\n        this.stateChanges.next();\n      }\n    }\n\n    _updateTextColorForDateType() {\n      const actualColor = getComputedStyle(this._elementRef.nativeElement).color;\n      this._color = actualColor !== 'rgba(0, 0, 0, 0)' ? actualColor : this._color;\n      const color = this.labelActive ? this._color : `transparent`;\n\n      this._renderer.setStyle(this._elementRef.nativeElement, 'color', color);\n    }\n\n    _onFocus() {\n      this._focused = true;\n\n      if (this._elementRef.nativeElement.type === 'date') {\n        this._updateTextColorForDateType();\n      }\n\n      this.stateChanges.next();\n    }\n\n    _onBlur() {\n      this._focused = false;\n\n      if (this._elementRef.nativeElement.type === 'date') {\n        this._updateTextColorForDateType();\n      }\n\n      this.stateChanges.next();\n    }\n\n    ngDoCheck() {\n      const value = this._elementRef.nativeElement.value;\n\n      if (this._currentNativeValue !== value) {\n        this._currentNativeValue = value;\n        this.stateChanges.next();\n      }\n    }\n\n    get hasValue() {\n      return this._elementRef.nativeElement.value !== '';\n    }\n\n    get focused() {\n      return this._focused;\n    }\n\n    get input() {\n      return this._elementRef.nativeElement;\n    }\n\n    get labelActive() {\n      return this.focused || this.hasValue;\n    }\n\n  }\n\n  MdbInputDirective.ɵfac = function MdbInputDirective_Factory(t) {\n    return new (t || MdbInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10));\n  };\n\n  MdbInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbInputDirective,\n    selectors: [[\"\", \"mdbInput\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MdbInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function MdbInputDirective_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        })(\"blur\", function MdbInputDirective_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      value: \"value\"\n    },\n    exportAs: [\"mdbInput\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MdbAbstractFormControl,\n      useExisting: MdbInputDirective\n    }])]\n  });\n  return MdbInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbFormsModule = /*#__PURE__*/(() => {\n  class MdbFormsModule {}\n\n  MdbFormsModule.ɵfac = function MdbFormsModule_Factory(t) {\n    return new (t || MdbFormsModule)();\n  };\n\n  MdbFormsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbFormsModule\n  });\n  MdbFormsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return MdbFormsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbFormsModule, {\n    declarations: function () {\n      return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MdbAbstractFormControl, MdbFormControlComponent, MdbFormsModule, MdbInputDirective, MdbLabelDirective }; //# sourceMappingURL=mdb-angular-ui-kit-forms.js.map","map":null,"metadata":{},"sourceType":"module"}